<style data-page="law">* {
        padding: 0;
        margin: 0;
        box-sizing: border-box;
    }

    body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
    }

    .container {
        max-width: 1400px;
        margin: 0 auto;
    }

    /* 顶部导航 */
    .nav-header {
        border: 2px solid black;
        padding: 5px;
        margin-bottom: 20px;
        background-color: white;
        display: flex;
        justify-content: space-between;
        align-items: center;
        width: calc(100% - 40px);
        position: fixed;
        z-index: 10;
        top: 100px;

    }

    .nav-header h1 {
        font-size: 24px;
    }

    .back-btn {
        color: black;
        text-decoration: none;
        cursor: pointer;
        font-size: 16px;
    }



    .books {
        margin-top: 62px;
        border-top: 2px solid black;
    }

    .book {
        border: 2px solid black;
        padding: 5px;
        border-top: none;
        display: flex;
        position: relative;

    }

    .book-img {
        flex: 0 0 100px;
    }

    .book-img img {
        width: 100%;
        height: auto;
        display: block;

    }

    .book-description {
        flex: 1;
        margin-left: 15px;
        display: flex;
        flex-direction: column;
    }



    .book-btn {
        display: flex;
        gap: 10px;
        position: absolute;
        bottom: 10px;
    }

    .book-btn>div {
        border: 2px solid black;
        cursor: pointer;

    }

    .book-btn>div:hover {
        background-color: black;
        color: white;
    }

    .book-btn .want.active {
        background-color: Black;
        color: white;

    }

    .book-btn .read.active {
        background-color: Black;
        color: white;

    }

    /* Modal 样式 */
    .modal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 1000;
        align-items: center;
        justify-content: center;
    }

    .modal.show {
        display: flex;
    }

    .modal-content {
        background-color: white;
        border: 2px solid black;
        padding: 20px;
        max-width: 600px;
        width: 90%;
        max-height: 80vh;
        overflow-y: auto;
    }

    .modal-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 20px;
        padding-bottom: 10px;
        border-bottom: 2px solid black;
    }

    .modal-header h2 {
        font-size: 20px;
    }

    .close-btn {
        cursor: pointer;
        font-size: 24px;
        border: none;
        background: none;
        padding: 0;
    }

    .note-form {
        margin-bottom: 20px;
    }

    .note-form textarea {
        width: 100%;
        min-height: 120px;
        padding: 10px;
        border: 2px solid black;
        font-family: inherit;
        font-size: 14px;
        resize: vertical;
    }

    .note-form button {
        margin-top: 10px;
        padding: 8px 20px;
        border: 2px solid black;
        background-color: white;
        cursor: pointer;
        font-size: 14px;
    }

    .note-form button:hover {
        background-color: black;
        color: white;
    }

    .notes-list {
        margin-top: 20px;
    }

    .note-item {
        border: 2px solid black;
        padding: 15px;
        margin-bottom: 10px;
    }

    .note-content {
        margin-bottom: 10px;
        line-height: 1.6;
        white-space: pre-wrap;
 
    }

    .note-meta {
        font-size: 12px;
        color: #666;
        display: flex;
        justify-content: space-between;
        align-items: center;
    }

    .note-delete {
        cursor: pointer;

        font-size: 12px;
    }

    .note-delete:hover {
        text-decoration: underline;
    }
    .note-print:hover {
        text-decoration: underline;
    }
    .loading {
        text-align: center;
        padding: 20px;
        color: #666;
    }

    .empty-notes {
        text-align: center;
        padding: 40px;
        color: #999;
    }

    .note-form textarea:focus,
    .note-form input:focus {
        outline: none;
        border: 2px solid black;
    }


    /* 在 .book 样式后添加 */
    .book-notes-area {
        display: none;
        border: 2px solid black;
        padding: 15px;
        border-top: none;
    }

    .book-notes-area.show {
        display: block;
    }

    .notes-navigation {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 15px;


    }

    .nav-arrow {
        cursor: pointer;
        padding: 5px 15px;
        border: 2px solid black;
        background-color: white;
        font-size: 18px;
    }

    .nav-arrow:hover {
        background-color: black;
        color: white;
    }

    .nav-arrow.disabled {
        opacity: 0.5;
        cursor: not-allowed;
    }



    .current-note {
        padding: 15px;
        border: 2px solid black;
        background-color: white;
        min-height: 100px;
    }

    .current-note-content {
        margin-bottom: 10px;
        line-height: 1.6;
        white-space: pre-wrap;
 
    }

    .current-note-meta {
        font-size: 12px;
        color: #666;
    }

/* 在CSS末尾添加注解样式 */


    @media(max-width:899px) {
        .nav-header {
            margin-top: -20px;
            width: calc(100% - 20px);
        }

        .books {
            margin-top: 54px;
        }

        .books {
            font-size: 16px;
        }

        .book-btn {
            display: flex;
            gap: 5px;
            position: absolute;
            bottom: 10px;
        }

        .book-description {
            flex: 1;
            margin-left: 10px;
            display: flex;
            flex-direction: column;
        }

    }</style><link href="/css/styles.c6120c67c82cba3af7ca.css" rel="stylesheet"><body><div class="container"><div class="nav-header"><h1>LAW</h1><a data-page="print" class="back-btn">← BACK TO LIBRARY</a></div><div class="books" id="booksContainer"></div></div><div class="modal" id="noteModal"><div class="modal-content"><div class="modal-header"><h2 id="modalBookTitle">Book Notes</h2><button class="close-btn" onclick="closeNoteModal()">×</button></div><div class="note-form"><div style="display: flex; gap: 10px; margin-bottom: 10px;"><input type="number" id="pageStart" placeholder="起始页" style="width: 100px; padding: 5px; border: 2px solid black;" oninput="this.style.borderColor='black'"> <span style="line-height: 30px;">-</span> <input type="number" id="pageEnd" placeholder="结束页" style="width: 100px; padding: 5px; border: 2px solid black;"></div><textarea id="noteContent" placeholder="Write your note here..."></textarea> <button onclick="saveNote()">Add Note</button></div><div class="notes-list" id="notesList"><div class="loading">Loading notes...</div></div></div></div><script>(function () {
            let bookNotesCache = {};
            let currentNoteIndex = {};
            let currentUser = null;
            let currentBookId = null;
            let noteAnnotations = {};

            console.log('Law页面开始加载');
            console.log('BOOKS_DATA 状态:', typeof window.BOOKS_DATA !== 'undefined' ? '已加载' : '未加载');
            console.log('supabase 状态:', typeof supabase !== 'undefined' ? '已加载' : '未加载');




            // 新增：动态生成书籍列表
            function renderBooks() {
                const booksContainer = document.getElementById('booksContainer');
                const lawBooks = Object.values(window.BOOKS_DATA).filter(book => book.category === 'law');

                if (lawBooks.length === 0) {
                    booksContainer.innerHTML = '<div class="empty-message">暂无法律类书籍</div>';
                    return;
                }

                booksContainer.innerHTML = lawBooks.map(book => `
            <div class="book" data-book-id="${book.id}" data-book-title="${book.title}">
                <div class="book-img">
                    <img src="${book.imgSrc}" alt="${book.title}" onerror="this.src='/images/default-book.jpg'">
                </div>
                <div class="book-description">
                    <div class="book-title">${book.title}</div>
                    <div class="book-meta">
                        ${book.author}${book.translator ? ' / ' + book.translator : ''} / ${book.publisher} / ${book.publishDate}${book.pages ? ' / Pages: ' + book.pages : ''}
                    </div>
                </div>
            </div>
        `).join('');
            }

            async function waitForDependencies() {
                return new Promise((resolve) => {
                    const checkDependencies = setInterval(() => {
                        if (typeof supabase !== 'undefined' && window.BOOKS_DATA) {
                            clearInterval(checkDependencies);
                            resolve();
                        }
                    }, 100);
                });
            }


            async function initLaw() {
                console.log('开始初始化Law页面');

                // 等待依赖项加载
                await waitForDependencies();

                // 渲染书籍列表
                renderBooks();

                await checkUser();
                initializeBookButtons(); // 初始化书籍按钮和笔记区域
                await updateBookCounts(); // 更新计数

                // ========== 新增：检查是否需要滚动到特定书籍 ==========
                const scrollToBookId = sessionStorage.getItem('scrollToBookId');
                const shouldOpenNotes = sessionStorage.getItem('openNotesArea');

                if (scrollToBookId) {
                    // 清除 sessionStorage
                    sessionStorage.removeItem('scrollToBookId');
                    sessionStorage.removeItem('openNotesArea');

                    // 等待页面渲染完成
                    setTimeout(async () => {
                        const bookElement = document.querySelector(`.book[data-book-id="${scrollToBookId}"]`);
                        if (bookElement) {
                            // 滚动到书籍位置
                            bookElement.scrollIntoView({ behavior: 'smooth', block: 'center' });


                            // 添加高亮效果
                            bookElement.style.backgroundColor = 'black';
                            bookElement.style.color = 'white';
                            bookElement.style.borderColor = 'white'; // 边框变白

                            const innerElements = bookElement.querySelectorAll('*');
                            const bookBtnDivs = bookElement.querySelectorAll('.book-btn > div'); // 特别选择按钮元素

                            innerElements.forEach(el => {
                                el.style.color = 'white';
                            });

                            // 特别处理按钮边框
                            bookBtnDivs.forEach(btn => {
                                btn.style.borderColor = 'white';
                            });

                            setTimeout(() => {
                                bookElement.style.backgroundColor = '';
                                bookElement.style.color = '';
                                bookElement.style.borderColor = ''; // 恢复边框颜色

                                // 恢复内部元素的颜色
                                innerElements.forEach(el => {
                                    el.style.color = '';
                                });

                                // 恢复按钮边框颜色
                                bookBtnDivs.forEach(btn => {
                                    btn.style.borderColor = '';
                                });
                            }, 1500);

                            // 如果需要打开笔记区域
                            if (shouldOpenNotes === 'true') {
                                const bookTitle = bookElement.dataset.bookTitle;
                                // 再等待一下，确保滚动完成
                                setTimeout(() => {
                                    toggleNotesArea(scrollToBookId, bookTitle);
                                }, 500);
                            }
                        }
                    }, 300);


                }
            }

            // 新增：初始化书籍按钮和笔记区域
            function initializeBookButtons() {
                const books = document.querySelectorAll('.book');

                books.forEach(book => {
                    const bookId = book.dataset.bookId;
                    const bookTitle = book.dataset.bookTitle;
                    const bookDescription = book.querySelector('.book-description');

                    if (book.querySelector('.book-btn')) {
                        return; // 如果已经初始化，跳过
                    }


                    // 创建按钮区域
                    const bookBtn = document.createElement('div');
                    bookBtn.className = 'book-btn';
                    bookBtn.innerHTML = `
            <div class="want" onclick="toggleWant('${bookId}')">
                WANT(<span class="want-count">0</span>)
            </div>
            <div class="read" onclick="toggleReading('${bookId}')">
                READ(<span class="read-count">0</span>)
            </div>
            <div class="note" onclick="toggleNotesArea('${bookId}', '${bookTitle}')">
                NOTES(<span class="note-count">0</span>)
            </div>
            <div class="add" onclick="openNoteModal('${bookId}', '${bookTitle}')">+</div>
        `;
                    bookDescription.appendChild(bookBtn);

                    // 创建笔记展开区域
                    const notesArea = document.createElement('div');
                    notesArea.className = 'book-notes-area';
                    notesArea.id = `notes-area-${bookId}`;
                    notesArea.innerHTML = `
            <div class="notes-navigation">
                <div class="nav-arrow" onclick="prevNote('${bookId}')">←</div>
                <div class="note-page-info">
                    <span id="current-note-index-${bookId}">0</span> / <span id="total-notes-${bookId}">0</span>
                </div>
                <div class="nav-arrow" onclick="nextNote('${bookId}')">→</div>
            </div>
            <div class="current-note" id="current-note-${bookId}">
                <div class="loading">Loading notes...</div>
            </div>
        `;
                    book.parentNode.insertBefore(notesArea, book.nextSibling);
                });
            }






            // 检查用户登录状态
            async function checkUser() {
                const { data: { user } } = await supabase.auth.getUser();
                currentUser = user;
                console.log('当前用户:', currentUser ? currentUser.id : '未登录');
            }

            async function updateBookCounts() {
                const books = document.querySelectorAll('.book');
                const bookIds = Array.from(books).map(book => book.dataset.bookId);

                try {
                    // 获取想读计数
                    const { data: wantCounts } = await supabase
                        .from('book_wants')
                        .select('book_id')
                        .in('book_id', bookIds);

                    const wantCountMap = {};
                    if (wantCounts) {
                        wantCounts.forEach(item => {
                            wantCountMap[item.book_id] = (wantCountMap[item.book_id] || 0) + 1;
                        });
                    }

                    // 获取在读计数
                    const { data: readingCounts } = await supabase
                        .from('book_readings')
                        .select('book_id')
                        .in('book_id', bookIds);

                    const readingCountMap = {};
                    if (readingCounts) {
                        readingCounts.forEach(item => {
                            readingCountMap[item.book_id] = (readingCountMap[item.book_id] || 0) + 1;
                        });
                    }

                    // 获取笔记计数
                    const { data: noteCounts } = await supabase
                        .from('book_notes')
                        .select('book_id')
                        .in('book_id', bookIds);

                    const noteCountMap = {};
                    if (noteCounts) {
                        noteCounts.forEach(item => {
                            noteCountMap[item.book_id] = (noteCountMap[item.book_id] || 0) + 1;
                        });
                    }

                    // 获取用户状态
                    let userWants = new Set();
                    let userReadings = new Set();

                    if (currentUser) {
                        const { data: wants } = await supabase
                            .from('book_wants')
                            .select('book_id')
                            .eq('user_id', currentUser.id)
                            .in('book_id', bookIds);

                        if (wants) {
                            wants.forEach(want => userWants.add(want.book_id));
                        }

                        const { data: readings } = await supabase
                            .from('book_readings')
                            .select('book_id')
                            .eq('user_id', currentUser.id)
                            .in('book_id', bookIds);

                        if (readings) {
                            readings.forEach(reading => userReadings.add(reading.book_id));
                        }
                    }

                    // 更新页面显示
                    books.forEach(book => {
                        const bookId = book.dataset.bookId;
                        const wantBtn = book.querySelector('.want');
                        const readBtn = book.querySelector('.read');

                        // 更新计数
                        book.querySelector('.want-count').textContent = wantCountMap[bookId] || 0;
                        book.querySelector('.read-count').textContent = readingCountMap[bookId] || 0;
                        book.querySelector('.note-count').textContent = noteCountMap[bookId] || 0;

                        if (wantBtn && readBtn) {
                            // 更新计数（无论是否登录都更新）
                            const wantCountEl = book.querySelector('.want-count');
                            const readCountEl = book.querySelector('.read-count');
                            const noteCountEl = book.querySelector('.note-count');

                            if (wantCountEl) wantCountEl.textContent = wantCountMap[bookId] || 0;
                            if (readCountEl) readCountEl.textContent = readingCountMap[bookId] || 0;
                            if (noteCountEl) noteCountEl.textContent = noteCountMap[bookId] || 0;

                            // 更新状态（如果用户已登录）
                            if (currentUser) {
                                if (userWants.has(bookId)) {
                                    wantBtn.classList.add('active');
                                } else {
                                    wantBtn.classList.remove('active');
                                }

                                if (userReadings.has(bookId)) {
                                    readBtn.classList.add('active');
                                } else {
                                    readBtn.classList.remove('active');
                                }
                            } else {
                                // 未登录时移除active状态
                                wantBtn.classList.remove('active');
                                readBtn.classList.remove('active');
                            }
                        }
                    });

                } catch (error) {
                    console.error('更新计数失败:', error);
                }
            }
            initLaw();

            // 切换"想读"状态
            window.toggleWant = async function (bookId) {


                if (!currentUser) {
                    alert('请先登录');
                    return;
                }

                try {
                    const { data: existingReading } = await supabase
                        .from('book_readings')
                        .select('id')
                        .eq('user_id', currentUser.id)
                        .eq('book_id', bookId)
                        .maybeSingle();

                    // 如果已经在读，先删除在读状态
                    if (existingReading) {
                        await supabase.from('book_readings').delete().eq('id', existingReading.id);
                    }
                    const { data: existingWant } = await supabase
                        .from('book_wants')
                        .select('id')
                        .eq('user_id', currentUser.id)
                        .eq('book_id', bookId)
                        .maybeSingle();

                    if (existingWant) {
                        // 如果已经想读，则取消想读
                        await supabase.from('book_wants').delete().eq('id', existingWant.id);
                    } else {
                        // 如果没有想读，则添加想读
                        await supabase.from('book_wants').insert([{ user_id: currentUser.id, book_id: bookId }]);
                    }
                    await updateBookCounts();
                } catch (error) {
                    console.error('操作失败:', error);
                    alert('操作失败，请重试');
                }
            }


            window.toggleReading = async function (bookId) {
                if (!currentUser) {
                    alert('请先登录');
                    return;
                }

                try {
                    // 检查是否已经想读
                    const { data: existingWant } = await supabase
                        .from('book_wants')
                        .select('id')
                        .eq('user_id', currentUser.id)
                        .eq('book_id', bookId)
                        .maybeSingle();

                    // 如果已经想读，先删除想读状态
                    if (existingWant) {
                        await supabase.from('book_wants').delete().eq('id', existingWant.id);
                    }

                    const { data: existingReading } = await supabase
                        .from('book_readings')
                        .select('id')
                        .eq('user_id', currentUser.id)
                        .eq('book_id', bookId)
                        .maybeSingle();

                    if (existingReading) {
                        // 如果已经在读，则取消在读
                        await supabase.from('book_readings').delete().eq('id', existingReading.id);
                    } else {
                        // 如果没有在读，则添加在读
                        await supabase.from('book_readings').insert([{ user_id: currentUser.id, book_id: bookId }]);
                    }

                    await updateBookCounts();
                } catch (error) {
                    console.error('操作失败:', error);
                    alert('操作失败，请重试');
                }
            }

            window.saveNote = async function () {
                if (!currentUser) {
                    alert('请先登录');
                    return;
                }

                const noteContent = document.getElementById('noteContent');
                const pageStart = document.getElementById('pageStart');
                const pageEnd = document.getElementById('pageEnd');
                const rawContent = noteContent.value.trim();
                const content = rawContent.split('\n').map(para => {
    
                    const trimmed = para.trim();
    if (trimmed === '') {
                return '';
            }
            
            let cleanPara = trimmed.replace(/^　+/g, '');
            return '　　' + cleanPara;
        }).join('\n');



                // 移除抖动效果
                pageStart.classList.remove('input-shake');
                pageEnd.classList.remove('input-shake');

                if (!content) {
                    alert('请输入笔记内容');
                    return;
                }

                // 验证页码：必须至少填写起始页
                if (!pageStart.value) {
                    alert('请填写页码');
                    return;
                }

                if (pageEnd.value && parseInt(pageEnd.value) < parseInt(pageStart.value)) {
                    alert('结束页不能小于起始页');
                    return;
                }

                try {
                    const noteData = {
                        user_id: currentUser.id,
                        book_id: currentBookId,
                        content: content,
                        page_start: pageStart.value ? parseInt(pageStart.value) : null,
                        page_end: pageEnd.value ? parseInt(pageEnd.value) : null
                    };

                    const { error } = await supabase
                        .from('book_notes')
                        .insert([noteData]);

                    if (error) throw error;

                    // 清空输入
                    noteContent.value = '';
                    pageStart.value = '';
                    pageEnd.value = '';

                    // 重新加载用户笔记
                    await loadUserNotes(currentBookId);

                    // 更新计数
                    await updateBookCounts();

                    // 如果笔记区域是展开的，刷新它
                    const notesArea = document.getElementById(`notes-area-${currentBookId}`);
                    if (notesArea && notesArea.classList.contains('show')) {
                        await loadAllNotes(currentBookId);
                        // 跳到最后一条笔记（刚添加的）
                        currentNoteIndex[currentBookId] = (bookNotesCache[currentBookId] || []).length - 1;
                        displayCurrentNote(currentBookId);
                    }

                } catch (error) {
                    console.error('保存笔记失败:', error);
                    alert('保存失败，请重试');
                }
            }



            // 打开笔记Modal
            window.openNoteModal = async function (bookId, bookTitle) {
                if (!currentUser) {
                    alert('请先登录');
                    return;
                }
                currentBookId = bookId;

                const modal = document.getElementById('noteModal');
                const modalTitle = document.getElementById('modalBookTitle');
                const noteContent = document.getElementById('noteContent');

                modalTitle.textContent = `${bookTitle}`;
                noteContent.value = '';
                modal.classList.add('show');

                await loadUserNotes(bookId);
            }

            // 关闭笔记Modal
            window.closeNoteModal = function () {
    const modal = document.getElementById('noteModal');
    modal.classList.remove('show');
    currentBookId = null;
    
    // 如果有展开的笔记区域，刷新它
    const openNotesArea = document.querySelector('.book-notes-area.show');
    if (openNotesArea) {
        const bookIdMatch = openNotesArea.id.match(/notes-area-(.+)/);
        if (bookIdMatch) {
            const bookId = bookIdMatch[1];
            // 强制刷新缓存并重新显示
            setTimeout(async () => {
                await loadAllNotes(bookId, true);
                await displayCurrentNote(bookId);
            }, 100);
        }
    }
}

            window.toggleNotesArea = async function (bookId, bookTitle) {

                const notesArea = document.getElementById(`notes-area-${bookId}`);

                // 如果已展开，则收起
                if (notesArea.classList.contains('show')) {
                    notesArea.classList.remove('show');
                    return;
                }

                // 收起其他所有展开的笔记区域
                document.querySelectorAll('.book-notes-area.show').forEach(area => {
                    area.classList.remove('show');
                });

                // 展开当前区域
                notesArea.classList.add('show');

                // 加载所有笔记（按页码排序）
                await loadAllNotes(bookId);

                // 显示第一条笔记
                currentNoteIndex[bookId] = 0;
                displayCurrentNote(bookId);
            }



            window.loadAllNotes = async function (bookId, forceRefresh = false) {
    try {
        // 如果强制刷新或缓存为空，从数据库重新加载
        if (forceRefresh || !bookNotesCache[bookId]) {
            const { data: notes, error } = await supabase
                .from('book_notes')
                .select('*')
                .eq('book_id', bookId)
                .order('page_start', { ascending: true, nullsFirst: false });

            if (error) throw error;

            // 缓存笔记数据
            bookNotesCache[bookId] = notes || [];

            // 为每条笔记获取并处理注解
            for (let note of bookNotesCache[bookId]) {
                const annotations = await getNoteAnnotations(note.id);
                
                // 如果数据库中有注解，但内容中没有标记，则添加标记
                if (annotations && annotations.length > 0) {
                    let content = note.content;
                    const hasMarkers = /[①-⑳⓪]/.test(content);
                    
                    if (!hasMarkers) {
                        // 按display_order排序
                        const sortedAnnotations = [...annotations].sort((a, b) => a.display_order - b.display_order);
                        
                        // 为每个注解查找原文并添加标记
                        sortedAnnotations.forEach(ann => {
                            if (ann.original_text && content.includes(ann.original_text)) {
                                const circledNum = getCircledNumber(ann.display_order);
                                // 只替换第一个匹配项
                                content = content.replace(ann.original_text, ann.original_text + circledNum);
                            }
                        });
                        
                        // 更新笔记内容
                        note.content = content;
                    }
                }
            }
        }

        // 更新总笔记数
        document.getElementById(`total-notes-${bookId}`).textContent = bookNotesCache[bookId].length;

    } catch (error) {
        console.error('加载笔记失败:', error);
        bookNotesCache[bookId] = [];
    }
}

   // 显示当前笔记
async function displayCurrentNote(bookId) {
    const notes = bookNotesCache[bookId] || [];
    const currentIndex = currentNoteIndex[bookId] || 0;
    const noteContainer = document.getElementById(`current-note-${bookId}`);

    if (notes.length === 0) {
        noteContainer.innerHTML = '<div class="empty-notes">还没有笔记</div>';
        document.getElementById(`current-note-index-${bookId}`).textContent = '0';
        return;
    }

    const note = notes[currentIndex];
    
    // 重新从数据库获取笔记和注解，确保是最新数据
    try {
        const { data: freshNote, error } = await supabase
            .from('book_notes')
            .select('*')
            .eq('id', note.id)
            .single();
            
        if (error) throw error;
        
        const annotations = await getNoteAnnotations(note.id);
        
        // 更新缓存中的笔记数据
        notes[currentIndex] = freshNote;
        
        // 获取用户信息
        const { data: profile } = await supabase
            .from('profiles')
            .select('manifesto')
            .eq('user_id', freshNote.user_id)
            .single();

        const userName = profile?.manifesto || 'Anonymous';
        const createdDate = new Date(freshNote.created_at).toLocaleDateString('zh-CN');

        let pageInfo = '';
        if (freshNote.page_start && freshNote.page_end) {
            pageInfo = `P${freshNote.page_start}-${freshNote.page_end}`;
        } else if (freshNote.page_start) {
            pageInfo = `P${freshNote.page_start}`;
        }

        // 检查是否是当前用户的笔记
        const isOwner = currentUser && currentUser.id === freshNote.user_id;
        const ownerButtons = isOwner ? `
            <span class="note-delete" onclick="editNoteFromArea('${freshNote.id}', '${bookId}', ${freshNote.page_start}, ${freshNote.page_end})" style="cursor: pointer; margin-left: 15px;">编辑</span>
            <span class="note-delete" onclick="deleteNoteFromArea('${freshNote.id}', '${bookId}')" style="cursor: pointer; margin-left: 10px;">删除</span>
        ` : '';

        const printButton = `<span class="note-print" onclick="printNote('${bookId}', ${currentIndex})" style="cursor: pointer; margin-left: 10px;">打印</span>`;

        // 渲染内容
        let contentWithAnnotations = freshNote.content;

        // 渲染注解部分
        const annotationsHtml = annotations && annotations.length > 0 ? `
            <div class="note-annotations" style="margin-top: 15px; padding-top: 15px; border-top: 1px solid #ddd;">
                <div style="font-weight: bold; margin-bottom: 10px; font-size: 14px;">注解:</div>
                ${annotations.map(ann => `
                    <div style="margin-bottom: 8px; line-height: 1.4; font-size: 13px;">
                        <span style="color: #0066cc; font-weight: bold; margin-right: 6px;">${getCircledNumber(ann.display_order)}</span>
                        <span>${ann.annotation_text || '（无注解内容）'}</span>
                    </div>
                `).join('')}
            </div>
        ` : '';

        noteContainer.innerHTML = `
            <div class="current-note-content" style="line-height: 1.6; margin-bottom: 15px; white-space: pre-wrap;">
                ${contentWithAnnotations}
            </div>
            ${annotationsHtml}
            <div class="current-note-meta">
                <span>${pageInfo ? pageInfo + ' · ' : ''}${userName} · ${createdDate}</span>
                ${ownerButtons}
                ${printButton}
            </div>
        `;

    } catch (error) {
        console.error('获取笔记详情失败:', error);
        noteContainer.innerHTML = '<div class="empty-notes">加载笔记失败</div>';
    }

    // 更新当前索引显示
    document.getElementById(`current-note-index-${bookId}`).textContent = currentIndex + 1;

    // 更新左右箭头状态
    updateNavigationButtons(bookId);
}

function extractOriginalContent(content) {
    // 简单的正则匹配来移除注解标记（如①、②等）
    const annotationMarkers = /[①-⑳⓪]\s*/g;
    let cleanedContent = content.replace(annotationMarkers, '');
    
    // 检查是否包含注解部分
    const hasAnnotations = content.includes('<div class="annotations-section">') || 
                          content.includes('注解:') ||
                          /[①-⑳⓪]/.test(content);
    
    // 如果包含注解HTML部分，移除它
    if (content.includes('<div class="annotations-section">')) {
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = content;
        const annotationSection = tempDiv.querySelector('.annotations-section');
        if (annotationSection) {
            annotationSection.remove();
        }
        cleanedContent = tempDiv.innerHTML;
    }
    
    return {
        originalContent: cleanedContent,
        hasAnnotations: hasAnnotations
    };
}

function injectAnnotationsIntoContent(content, annotations) {
    if (!annotations || annotations.length === 0) {
        return content;
    }

    // 创建一个临时容器来解析HTML
    const tempDiv = document.createElement('div');
    tempDiv.innerHTML = content;
    
    // 按显示顺序排序注解
    const sortedAnnotations = [...annotations].sort((a, b) => a.display_order - b.display_order);
    
    // 在笔记末尾添加注解内容
    let resultContent = content;
    
    // 添加注解列表
    if (sortedAnnotations.length > 0) {
        resultContent += '\n\n<div class="annotations-section">';
        resultContent += '<div class="annotations-title" style="font-weight: bold; margin-top: 20px; padding-top: 20px; border-top: 1px solid #ddd;">注解:</div>';
        
        sortedAnnotations.forEach(ann => {
            resultContent += `
                <div class="annotation-item" style="margin-bottom: 10px;">
                    <span class="annotation-marker" style="color: #0066cc; font-weight: bold;">${getCircledNumber(ann.display_order)}</span>
                    <span class="annotation-text">${ann.annotation_text}</span>
                </div>
            `;
        });
        
        resultContent += '</div>';
    }
    
    return resultContent;
}

async function saveAnnotationsToDatabase(noteId, annotations) {
    try {
        // 先删除该笔记的所有旧注解
        const { error: deleteError } = await supabase
            .from('note_annotations')
            .delete()
            .eq('note_id', noteId);

        if (deleteError) throw deleteError;

        // 如果有新注解，插入到数据库
        if (annotations && annotations.length > 0) {
            // 按注解的number字段排序
            const sortedAnnotations = [...annotations].sort((a, b) => a.number - b.number);
            
            const annotationsToInsert = sortedAnnotations.map((ann, index) => ({
                note_id: noteId,
                original_text: ann.text, // 保存原文
                annotation_text: ann.note || '',
                display_order: ann.number,
                created_at: new Date().toISOString()
            }));

            const { error: insertError } = await supabase
                .from('note_annotations')
                .insert(annotationsToInsert);

            if (insertError) throw insertError;
        }
    } catch (error) {
        console.error('保存注解失败:', error);
        throw error;
    }
}


async function getNoteAnnotations(noteId) {
    try {
        const { data: annotations, error } = await supabase
            .from('note_annotations')
            .select('*')
            .eq('note_id', noteId)
            .order('display_order', { ascending: true });

        if (error) throw error;
        return annotations || [];
    } catch (error) {
        console.error('获取注解失败:', error);
        return [];
    }
}


function renderAnnotationsForDisplay(annotations) {
    if (!annotations || annotations.length === 0) {
        return '';
    }

    // 按显示顺序排序
    const sortedAnnotations = [...annotations].sort((a, b) => a.display_order - b.display_order);
    
    return `
        <div style="margin-top: 20px; padding-top: 15px; border-top: 1px solid #ddd;">
            <div style="font-weight: bold; margin-bottom: 10px; font-size: 14px;">注解:</div>
            ${sortedAnnotations.map(ann => `
                <div style="margin-bottom: 8px; line-height: 1.4; font-size: 13px;">
                    <span style="color: #0066cc; font-weight: bold; margin-right: 6px;">${getCircledNumber(ann.display_order)}</span>
                    <span>${ann.annotation_text || '（无注解内容）'}</span>
                </div>
            `).join('')}
        </div>
    `;
}

window.editNoteFromArea = async function (noteId, bookId, pageStart, pageEnd) {
    const noteContainer = document.getElementById(`current-note-${bookId}`);
    
    // 从数据库加载已有注解
    const existingAnnotations = await getNoteAnnotations(noteId);
    
    // 初始化noteAnnotations数组
    if (!noteAnnotations[noteId]) {
        noteAnnotations[noteId] = [];
    }
    
    // 清空现有注解并重新添加
    noteAnnotations[noteId] = [];
    
    if (existingAnnotations && existingAnnotations.length > 0) {
        // 按display_order排序
        const sortedAnnotations = [...existingAnnotations].sort((a, b) => a.display_order - b.display_order);
        
        sortedAnnotations.forEach(ann => {
            noteAnnotations[noteId].push({
                id: ann.id || Date.now(),
                number: ann.display_order,
                text: ann.original_text || '',
                note: ann.annotation_text || ''
            });
        });
    }

    // 获取笔记内容
    const notes = bookNotesCache[bookId] || [];
    const note = notes.find(n => n.id === noteId);
    
    if (!note) {
        alert('笔记未找到');
        return;
    }
    

    // 获取内容，保留已有的带圈数字标记
    // 注意：这里应该显示数据库中的原始内容，包含标记
    let contentToEdit = note.content;
    contentToEdit = contentToEdit.replace(/[①-⑳⓪]/g, '');
    // 移除每段开头的全角空格，编辑时不需要它们
    // contentToEdit = contentToEdit.split('\n').map(para => {
    //     const trimmed = para.trim();
    //     if (trimmed === '') {
    //         return '';
    //     }
    //     // 移除开头的全角空格，编辑时不需要它们
    //     return trimmed.replace(/^　+/g, '');
    // }).join('\n');



    noteContainer.innerHTML = `
        <div style="margin-bottom: 10px;">
            <div style="display: flex; gap: 10px; margin-bottom: 10px;">
                <input type="number" id="area-edit-pageStart-${noteId}" value="${pageStart || ''}" placeholder="起始页" 
                    style="width: 100px; padding: 5px; border: 2px solid black;">
                <span style="line-height: 30px;">-</span>
                <input type="number" id="area-edit-pageEnd-${noteId}" value="${pageEnd || ''}" placeholder="结束页" 
                    style="width: 100px; padding: 5px; border: 2px solid black;">
            </div>
            <div style="margin-bottom: 10px;">
                <button onclick="addAnnotationFromArea('${noteId}', '${bookId}')" style="padding: 5px 15px; border: 2px solid black; background-color: white; cursor: pointer;">添加注解</button>
                <span style="margin-left: 10px; font-size: 12px; color: #666;">选中文字后点击此按钮</span>
            </div>
            <div id="area-edit-content-${noteId}" contenteditable="true" style="width: 100%; min-height: 120px; padding: 10px; border: 2px solid black; font-family: inherit; font-size: 14px; overflow-y: auto; white-space: pre-wrap; line-height: 1.6;">${contentToEdit}</div>
            <div id="area-annotations-${noteId}" style="margin-top: 15px; padding-top: 15px; border-top: 2px solid black;">
                <!-- 注解列表将在这里显示 -->
            </div>
        </div>
        <div style="display: flex; gap: 10px;">
            <button id="area-save-btn-${noteId}" onclick="saveEditNoteFromArea('${noteId}', '${bookId}')" style="padding: 5px 15px; border: 2px solid black; background-color: white; cursor: pointer;">保存</button>
            <button onclick="cancelEditNoteFromArea('${bookId}')" style="padding: 5px 15px; border: 2px solid black; background-color: white; cursor: pointer;">取消</button>
        </div>
    `;

    // 渲染注解列表
    renderAnnotationsFromArea(noteId);
}

window.cancelEditNoteFromArea = function(bookId) {
    // 重新显示当前笔记
    displayCurrentNote(bookId);
}

function insertAnnotationMarksInEditContent(noteId) {
    const editContent = document.getElementById(`area-edit-content-${noteId}`);
    const annotations = noteAnnotations[noteId] || [];
    
    if (annotations.length === 0) return;
    
    let content = editContent.textContent || editContent.innerText;
    
    // 为每个注解在内容中查找并标记（简化版：在末尾添加）
    annotations.forEach(ann => {
        // 尝试在文本中找到原文
        const textIndex = content.indexOf(ann.text);
        if (textIndex !== -1) {
            // 在找到的文本后插入标记
            const before = content.substring(0, textIndex + ann.text.length);
            const after = content.substring(textIndex + ann.text.length);
            content = before + getCircledNumber(ann.number) + after;
        }
    });
    
    editContent.innerHTML = content;
}


     

            window.addAnnotationFromArea = function(noteId, bookId) {
    const selection = window.getSelection();
    if (!selection.rangeCount || selection.isCollapsed) {
        alert('请先选中需要注解的文字');
        return;
    }

    const selectedText = selection.toString();
    const range = selection.getRangeAt(0);
    const editContent = document.getElementById(`area-edit-content-${noteId}`);
    
    // 确保选区在编辑区域内
    if (!editContent.contains(range.commonAncestorContainer)) {
        alert('请在笔记内容区域选择文字');
        return;
    }

    // 获取当前所有注解，计算下一个序号
    const currentAnnotations = noteAnnotations[noteId] || [];
    const nextNumber = currentAnnotations.length + 1;

    // 创建注解
    const annotation = {
        id: Date.now(),
        number: nextNumber, // 这是显示顺序，不是创建时间
        text: selectedText,
        note: ''
    };

    // 在选中文字后插入带圈数字
    const circledNumber = getCircledNumber(nextNumber);
    const span = document.createElement('span');
    span.style.color = '#0066cc';
    span.style.fontSize = '0.85em';
    span.style.verticalAlign = 'super';
    span.textContent = circledNumber;
    
    range.collapse(false);
    range.insertNode(span);

    // 保存注解到数组
    if (!noteAnnotations[noteId]) {
        noteAnnotations[noteId] = [];
    }
    noteAnnotations[noteId].push(annotation);
    
    // 清除选区
    selection.removeAllRanges();
    
    // 重新渲染注解列表
    renderAnnotationsFromArea(noteId);
}

// 同样修改addAnnotation函数（用于modal中的编辑）
window.addAnnotation = function(noteId) {
    const selection = window.getSelection();
    if (!selection.rangeCount || selection.isCollapsed) {
        alert('请先选中需要注解的文字');
        return;
    }

    const selectedText = selection.toString();
    const range = selection.getRangeAt(0);
    const editContent = document.getElementById(`edit-content-${noteId}`);
    
    // 确保选区在编辑区域内
    if (!editContent.contains(range.commonAncestorContainer)) {
        alert('请在笔记内容区域选择文字');
        return;
    }

    // 获取当前所有注解，计算下一个序号
    const currentAnnotations = noteAnnotations[noteId] || [];
    const nextNumber = currentAnnotations.length + 1;

    // 创建注解
    const annotation = {
        id: Date.now(),
        number: nextNumber,
        text: selectedText,
        note: ''
    };


    // 在选中文字后插入带圈数字
    const circledNumber = getCircledNumber(nextNumber);
    const span = document.createElement('span');
    span.style.color = '#0066cc';
    span.style.fontSize = '0.85em';
    span.style.verticalAlign = 'super';
    span.textContent = circledNumber;
    
    range.collapse(false);
    range.insertNode(span);

    // 保存注解
    if (!noteAnnotations[noteId]) {
        noteAnnotations[noteId] = [];
    }
    noteAnnotations[noteId].push(annotation);
    
    // 清除选区
    selection.removeAllRanges();
    
    // 重新渲染注解列表
    renderAnnotations(noteId);
}

// 渲染展开区域的注解列表
// 渲染展开区域的注解列表 - 修复版
function renderAnnotationsFromArea(noteId) {
    const annotationsContainer = document.getElementById(`area-annotations-${noteId}`);
    if (!annotationsContainer) return;

    const annotations = noteAnnotations[noteId] || [];
    
    if (annotations.length === 0) {
        annotationsContainer.innerHTML = '<div style="color: #999; font-size: 14px;">暂无注解</div>';
        return;
    }

    annotationsContainer.innerHTML = annotations.map(ann => `
        <div style="margin-bottom: 15px; padding: 10px; border: 2px solid black; background-color: white;">
            <div style="margin-bottom: 5px;">
                <span style="color: black; font-weight: bold;">${getCircledNumber(ann.number)}</span>
                <span style="color: black; font-size: 14px;">"${ann.text}"</span>
                <button onclick="deleteAnnotationFromArea('${noteId}', '${ann.id}')" style="float: right; padding: 0px 8px; border: 2px solid black; background: white; cursor: pointer; font-size: 12px;">删除</button>
            </div>
            <textarea id="area-annotation-note-${ann.id}" style="width: 100%; min-height: 60px; padding: 5px; border: 2px solid black; font-size: 13px;" placeholder="在此输入注解内容...">${ann.note}</textarea>
        </div>
    `).join('');

    // 绑定textarea的change事件
    annotations.forEach(ann => {
        const textarea = document.getElementById(`area-annotation-note-${ann.id}`);
        if (textarea) {
            textarea.addEventListener('input', function() {
                const annotation = noteAnnotations[noteId].find(a => a.id === ann.id);
                if (annotation) {
                    annotation.note = this.value;
                }
            });
        }
    });
}// 从展开区域删除注解 - 修复版
window.deleteAnnotationFromArea = function(noteId, annotationId) {
    if (!confirm(`确定删除这条注解吗？`)) return;

    const annotations = noteAnnotations[noteId] || [];
    const deleteIndex = annotations.findIndex(a => a.id == annotationId);
    if (deleteIndex === -1) return;

    // 1. 从数组中删除注解
    annotations.splice(deleteIndex, 1);

    // 2. 重新编号所有剩余的注解
    annotations.forEach((ann, idx) => {
        ann.number = idx + 1;
    });

    // 3. 更新编辑区域中的标记
    const editContent = document.getElementById(`area-edit-content-${noteId}`);
    const modalEditContent = document.getElementById(`edit-content-${noteId}`);
    
    // 更新展开区域的内容
    if (editContent) {
        updateContentWithAnnotations(editContent, annotations);
    }
    
    // 更新Modal中的内容（如果存在）
    if (modalEditContent) {
        updateContentWithAnnotations(modalEditContent, annotations);
    }

    // 4. 重新渲染注解列表
    renderAnnotationsFromArea(noteId);
    
    // 5. 如果Modal中也显示了相同的笔记，更新Modal中的注解列表
    const modalAnnotationsContainer = document.getElementById(`annotations-${noteId}`);
    if (modalAnnotationsContainer) {
        renderAnnotations(noteId);
    }
}


// 辅助函数：更新内容中的注解标记
function updateContentWithAnnotations(contentElement, annotations) {
    if (!contentElement) return;
    
    // 获取当前文本内容（不含标记）
    let textContent = contentElement.textContent || contentElement.innerText;
    
    // 移除所有现有的带圈数字标记
    textContent = textContent.replace(/[①-⑳⓪]/g, '');
    
    // 清除当前内容
    contentElement.innerHTML = '';
    
    // 如果有注解，插入新的标记
    if (annotations && annotations.length > 0) {
        // 创建文本节点并重新插入
        const sortedAnnotations = [...annotations].sort((a, b) => a.number - b.number);
        
        // 创建一个文档片段来构建新内容
        const fragment = document.createDocumentFragment();
        
        // 处理文本行
        const lines = textContent.split('\n');
        
        lines.forEach((line, lineIndex) => {
            if (lineIndex > 0) {
                fragment.appendChild(document.createElement('br'));
            }
            
            let processedLine = line;
            let offset = 0;
            
            // 为每个注解在行中查找并标记
            sortedAnnotations.forEach(ann => {
                if (ann.text && processedLine.includes(ann.text)) {
                    // 找到文本位置
                    const textIndex = processedLine.indexOf(ann.text);
                    if (textIndex !== -1) {
                        // 添加注解文本前的部分
                        if (textIndex > 0) {
                            const beforeText = document.createTextNode(processedLine.substring(0, textIndex));
                            fragment.appendChild(beforeText);
                        }
                        
                        // 添加注解文本
                        const annotationText = document.createTextNode(ann.text);
                        fragment.appendChild(annotationText);
                        
                        // 添加带圈数字标记
                        const markerSpan = document.createElement('span');
                        markerSpan.style.color = '#0066cc';
                        markerSpan.style.fontSize = '0.85em';
                        markerSpan.style.verticalAlign = 'super';
                        markerSpan.textContent = getCircledNumber(ann.number);
                        fragment.appendChild(markerSpan);
                        
                        // 更新已处理的行内容
                        processedLine = processedLine.substring(textIndex + ann.text.length);
                    }
                }
            });
            
            // 添加剩余的行内容
            if (processedLine.length > 0) {
                const remainingText = document.createTextNode(processedLine);
                fragment.appendChild(remainingText);
            }
        });
        
        contentElement.appendChild(fragment);
    } else {
        // 没有注解，直接设置文本
        // 保持原有的换行
        const lines = textContent.split('\n');
        lines.forEach((line, index) => {
            if (index > 0) {
                contentElement.appendChild(document.createElement('br'));
            }
            contentElement.appendChild(document.createTextNode(line));
        });
    }
}
window.saveEditNoteFromArea = async function (noteId, bookId) {
    const saveBtn = document.getElementById(`area-save-btn-${noteId}`);
    const originalText = saveBtn.textContent;
    
    // 显示保存中状态
    saveBtn.textContent = '保存中...';
    saveBtn.disabled = true;
    saveBtn.style.opacity = '0.7';
    saveBtn.style.cursor = 'not-allowed';

    try {
        const contentElement = document.getElementById(`area-edit-content-${noteId}`);
        const pageStartElement = document.getElementById(`area-edit-pageStart-${noteId}`);
        const pageEndElement = document.getElementById(`area-edit-pageEnd-${noteId}`);

        // 获取包含HTML的内容
        let htmlContent = contentElement.innerHTML;
        
        // 移除旧的带圈数字标记
        htmlContent = htmlContent.replace(/<span[^>]*>[①-⑳⓪]<\/span>/g, '');
        htmlContent = htmlContent.replace(/[①-⑳⓪]/g, '');
        
        // 转换为纯文本
      
        let content = contentElement.textContent || contentElement.innerText;
        
        // 更彻底地清理内容
        // 移除所有不可见的空白字符（除了换行）
        content = content
            .replace(/\r/g, '') // 移除回车符
            .replace(/[\t]/g, ' ') // 制表符替换为空格
            .replace(/\s+/g, ' ') // 多个连续空格合并为一个
            .trim();
        
        // 将内容按行分割，处理空行
        const lines = content.split('\n');
        
        // 处理每行，确保第一行也有两个全角空格
        content = lines.map((line, index) => {
            const trimmed = line.trim();
            if (trimmed === '') {
                return ''; // 保持空行
            }
            
            // 移除已有的全角空格，然后添加两个全角空格
            // 这里的关键：第一行也要处理
            let cleanLine = trimmed.replace(/^　+/g, '');
            return '　　' + cleanLine;
        }).join('\n');
        
        const pageStart = pageStartElement.value;
        const pageEnd = pageEndElement.value;

        if (!content) {
            alert('请输入笔记内容');
            throw new Error('内容为空');
        }

        // 验证页码
        if (!pageStart) {
            alert('请填写页码');
            throw new Error('页码为空');
        }

        if (pageEnd && parseInt(pageEnd) < parseInt(pageStart)) {
            alert('结束页不能小于起始页');
            throw new Error('页码错误');
        }

        // 更新笔记内容（包含标记）
        const { error: noteError } = await supabase
            .from('book_notes')
            .update({
                content: content,
                page_start: parseInt(pageStart),
                page_end: pageEnd ? parseInt(pageEnd) : null,
                updated_at: new Date().toISOString()
            })
            .eq('id', noteId);

        if (noteError) throw noteError;
        
        // 保存注解到数据库
        const annotations = noteAnnotations[noteId] || [];
        if (annotations.length > 0) {
            // 删除旧的注解
            const { error: deleteError } = await supabase
                .from('note_annotations')
                .delete()
                .eq('note_id', noteId);
            
            if (deleteError) throw deleteError;
            
            // 插入新的注解
            const annotationsToInsert = annotations.map((ann, index) => ({
                note_id: noteId,
                original_text: ann.text,
                annotation_text: ann.note || '',
                display_order: ann.number,
                created_at: new Date().toISOString()
            }));
            
            const { error: insertError } = await supabase
                .from('note_annotations')
                .insert(annotationsToInsert);
                
            if (insertError) throw insertError;
        } else {
            // 如果没有注解，删除所有相关注解
            await supabase
                .from('note_annotations')
                .delete()
                .eq('note_id', noteId);
        }
        
        // 清除缓存
        delete bookNotesCache[bookId];
        delete noteAnnotations[noteId];
        
        // 重新加载笔记
        await loadAllNotes(bookId);
        await updateBookCounts();

        // 重新显示当前笔记
        await displayCurrentNote(bookId);

        // 恢复按钮状态
        saveBtn.textContent = '保存成功!';
        setTimeout(() => {
            saveBtn.textContent = originalText;
            saveBtn.disabled = false;
            saveBtn.style.opacity = '1';
            saveBtn.style.cursor = 'pointer';
        }, 1000);

    } catch (error) {
        console.error('更新笔记失败:', error);
        
        // 恢复按钮状态
        saveBtn.textContent = originalText;
        saveBtn.disabled = false;
        saveBtn.style.opacity = '1';
        saveBtn.style.cursor = 'pointer';
        
        if (error.message !== '内容为空' && error.message !== '页码为空' && error.message !== '页码错误') {
            alert('更新失败，请重试');
        }
    }
}
            // 新增：更新导航按钮状态
            function updateNavigationButtons(bookId) {
                const notes = bookNotesCache[bookId] || [];
                const currentIndex = currentNoteIndex[bookId] || 0;

                const prevBtn = document.querySelector(`#notes-area-${bookId} .nav-arrow:first-child`);
                const nextBtn = document.querySelector(`#notes-area-${bookId} .nav-arrow:last-child`);

                // 更新上一条按钮
                if (currentIndex === 0) {
                    prevBtn.classList.add('disabled');
                } else {
                    prevBtn.classList.remove('disabled');
                }

                // 更新下一条按钮
                if (currentIndex >= notes.length - 1) {
                    nextBtn.classList.add('disabled');
                } else {
                    nextBtn.classList.remove('disabled');
                }
            }

            // 新增：上一条笔记
            window.prevNote = function (bookId) {
                const currentIndex = currentNoteIndex[bookId] || 0;
                if (currentIndex > 0) {
                    currentNoteIndex[bookId] = currentIndex - 1;
                    displayCurrentNote(bookId);
                }
            }

            // 新增：下一条笔记
            window.nextNote = function (bookId) {
                const notes = bookNotesCache[bookId] || [];
                const currentIndex = currentNoteIndex[bookId] || 0;
                if (currentIndex < notes.length - 1) {
                    currentNoteIndex[bookId] = currentIndex + 1;
                    displayCurrentNote(bookId);
                }
            }



            async function loadUserNotes(bookId) {
    const notesList = document.getElementById('notesList');
    notesList.innerHTML = '<div class="loading">Loading notes...</div>';

    if (!currentUser) {
        notesList.innerHTML = '<div class="empty-notes">请先登录</div>';
        return;
    }

    try {
        // 只查询当前用户的笔记
        const { data: notes, error } = await supabase
            .from('book_notes')
            .select('*')
            .eq('book_id', bookId)
            .eq('user_id', currentUser.id)
            .order('created_at', { ascending: false });

        if (error) throw error;

        if (!notes || notes.length === 0) {
            notesList.innerHTML = '<div class="empty-notes">你还没有添加笔记</div>';
            return;
        }

        // 为每条笔记获取注解
        const notesWithAnnotations = await Promise.all(
            notes.map(async (note) => {
                const annotations = await getNoteAnnotations(note.id);
                
                let content = note.content;
                
                // 如果内容中没有标记但有注解，添加标记
                if (annotations && annotations.length > 0 && !/[①-⑳⓪]/.test(content)) {
                    const sortedAnnotations = [...annotations].sort((a, b) => a.display_order - b.display_order);
                    
                    sortedAnnotations.forEach(ann => {
                        if (ann.original_text && content.includes(ann.original_text)) {
                            const circledNum = getCircledNumber(ann.display_order);
                            // 只替换第一个匹配项
                            content = content.replace(ann.original_text, ann.original_text + circledNum);
                        }
                    });
                }
                
                return { ...note, content, annotations };
            })
        );



        notesList.innerHTML = notesWithAnnotations.map(note => {
            const createdDate = new Date(note.created_at).toLocaleDateString('zh-CN');

            let pageInfo = '';
            if (note.page_start && note.page_end) {
                pageInfo = `P${note.page_start}-${note.page_end} · `;
            } else if (note.page_start) {
                pageInfo = `P${note.page_start} · `;
            }

            // 渲染注解部分
            const annotationsHtml = note.annotations && note.annotations.length > 0 ? `
                <div class="note-annotations" style="margin-top: 10px; padding-top: 10px; border-top: 1px solid #eee;">
                    <div style="font-weight: bold; margin-bottom: 8px; font-size: 13px;">注解:</div>
                    ${note.annotations.map(ann => `
                        <div style="margin-bottom: 6px; line-height: 1.4; font-size: 12px;">
                            <span style="color: #0066cc; font-weight: bold; margin-right: 4px;">${getCircledNumber(ann.display_order)}</span>
                            <span>${ann.annotation_text || '（无注解内容）'}</span>
                        </div>
                    `).join('')}
                </div>
            ` : '';

            return `
                <div class="note-item" id="note-item-${note.id}">
                    <div class="note-content" id="note-content-${note.id}">${note.content}</div>
                    ${annotationsHtml}
                    <div class="note-meta">
                        <span>${pageInfo}${createdDate}</span>
                        <span>
                            <span class="note-delete" onclick="editNote('${note.id}', ${note.page_start}, ${note.page_end})" style="cursor: pointer; margin-right: 10px;">编辑</span>
                            <span class="note-delete" onclick="deleteNote('${note.id}')">删除</span>
                        </span>
                    </div>
                </div>
            `;
        }).join('');

    } catch (error) {
        console.error('加载笔记失败:', error);
        notesList.innerHTML = '<div class="empty-notes">加载笔记失败</div>';
    }
}

            // 编辑笔记
            window.editNote = function (noteId, pageStart, pageEnd) {
    const noteContentElement = document.getElementById(`note-content-${noteId}`);
    const noteItemElement = document.getElementById(`note-item-${noteId}`);
    const currentContent = noteContentElement.textContent;
    
    // 清空现有的注解缓存
    if (!noteAnnotations[noteId]) {
        noteAnnotations[noteId] = [];
    } else {
        noteAnnotations[noteId] = [];
    }

    // 从数据库加载已有注解
    getNoteAnnotations(noteId).then(async (annotations) => {
        if (annotations && annotations.length > 0) {
            annotations.forEach(ann => {
                noteAnnotations[noteId].push({
                    id: ann.id || Date.now(),
                    number: ann.display_order,
                    text: ann.original_text || '',
                    note: ann.annotation_text || ''
                });
            });
        }


        let editContent = currentContent;

        editContent = editContent.replace(/[①-⑳⓪]/g, '');

        noteItemElement.innerHTML = `
        <div style="margin-bottom: 10px;">
            <div style="display: flex; gap: 10px; margin-bottom: 10px;">
                <input type="number" id="edit-pageStart-${noteId}" value="${pageStart || ''}" placeholder="起始页" 
                    style="width: 100px; padding: 5px; border: 2px solid black;"
                    oninput="this.style.borderColor='black'">
                <span style="line-height: 30px;">-</span>
                <input type="number" id="edit-pageEnd-${noteId}" value="${pageEnd || ''}" placeholder="结束页" 
                    style="width: 100px; padding: 5px; border: 2px solid black;"
                    oninput="this.style.borderColor='black'">
            </div>
            <div style="margin-bottom: 10px;">
                <button onclick="addAnnotation('${noteId}')" style="padding: 5px 15px; border: 2px solid black; background-color: white; cursor: pointer;">添加注解</button>
                <span style="margin-left: 10px; font-size: 12px; color: #666;">选中文字后点击此按钮</span>
            </div>
            <div id="edit-content-${noteId}" contenteditable="true" style="width: 100%; min-height: 120px; padding: 10px; border: 2px solid black; font-family: inherit; font-size: 14px; overflow-y: auto; white-space: pre-wrap;">${currentContent}</div>
            <div id="annotations-${noteId}" style="margin-top: 15px; padding-top: 15px; border-top: 2px solid black;">
                <!-- 注解列表将在这里显示 -->
            </div>
        </div>
        <div style="display: flex; gap: 10px;">
            <button onclick="saveEditNote('${noteId}')" style="padding: 5px 15px; border: 2px solid black; background-color: white; cursor: pointer;">保存</button>
            <button onclick="cancelEditNoteInModal('${noteId}')" style="padding: 5px 15px; border: 2px solid black; background-color: white; cursor: pointer;">取消</button>
        </div>
    `;

        // 渲染已有注解
        renderAnnotations(noteId);
        
        // 在内容中插入注解标记
        insertAnnotationMarksInModalContent(noteId, annotations);
    }).catch(error => {
        console.error('加载注解失败:', error);
    });
}

window.cancelEditNoteInModal = function(noteId) {
    // 重新加载笔记列表
    loadUserNotes(currentBookId);
}


function insertAnnotationMarksInModalContent(noteId, annotations) {
    if (!annotations || annotations.length === 0) return;
    
    const editContent = document.getElementById(`edit-content-${noteId}`);
    let content = editContent.textContent || editContent.innerText;
    
    // 检查是否已经包含带圈数字标记
    const hasExistingMarkers = /[①-⑳⓪]/.test(content);
    
    // 如果已经有标记，先移除所有标记
    if (hasExistingMarkers) {
        content = content.replace(/[①-⑳⓪]/g, '');
    }
    
    // 按顺序插入标记
    const sortedAnnotations = [...annotations].sort((a, b) => a.display_order - b.display_order);
    
    sortedAnnotations.forEach(ann => {
        if (ann.original_text && content.includes(ann.original_text)) {
            const circledNum = getCircledNumber(ann.display_order);
            // 替换第一个匹配项，在原文后添加标记
            content = content.replace(ann.original_text, ann.original_text + circledNum);
        }
    });
    
    editContent.innerHTML = content;
}

            // 添加注解
            window.addAnnotation = function(noteId) {
    const selection = window.getSelection();
    if (!selection.rangeCount || selection.isCollapsed) {
        alert('请先选中需要注解的文字');
        return;
    }

    const selectedText = selection.toString();
    const range = selection.getRangeAt(0);
    const editContent = document.getElementById(`edit-content-${noteId}`);
    
    // 确保选区在编辑区域内
    if (!editContent.contains(range.commonAncestorContainer)) {
        alert('请在笔记内容区域选择文字');
        return;
    }

    // 获取当前所有注解，计算下一个序号
    const currentAnnotations = noteAnnotations[noteId] || [];
    const nextNumber = currentAnnotations.length + 1;

    // 创建注解
    const annotation = {
        id: Date.now(),
        number: nextNumber,
        text: selectedText,
        note: ''
    };

    // 在选中文字后插入带圈数字
    const circledNumber = getCircledNumber(nextNumber);
    const span = document.createElement('span');
    span.style.color = '#0066cc';
    span.style.fontSize = '0.85em';
    span.style.verticalAlign = 'super';
    span.textContent = circledNumber;
    
    range.collapse(false);
    range.insertNode(span);

    // 保存注解
    if (!noteAnnotations[noteId]) {
        noteAnnotations[noteId] = [];
    }
    noteAnnotations[noteId].push(annotation);
    
    // 清除选区
    selection.removeAllRanges();
    
    // 重新渲染注解列表
    renderAnnotations(noteId);
}

            
            function getCircledNumber(num) {
                const circledNumbers = ['⓪','①','②','③','④','⑤','⑥','⑦','⑧','⑨','⑩',
                                       '⑪','⑫','⑬','⑭','⑮','⑯','⑰','⑱','⑲','⑳'];
                if (num <= 20) {
                    return circledNumbers[num];
                }
                return `(${num})`;
            }

            // 渲染注解列表
            function renderAnnotations(noteId) {
    const annotationsContainer = document.getElementById(`annotations-${noteId}`);
    if (!annotationsContainer) return;

    const annotations = noteAnnotations[noteId] || [];
    
    if (annotations.length === 0) {
        annotationsContainer.innerHTML = '<div style="color: #999; font-size: 14px;">暂无注解</div>';
        return;
    }

    annotationsContainer.innerHTML = annotations.map(ann => `
        <div style="margin-bottom: 15px; padding: 10px; border: 2px solid black; background-color: white;">
            <div style="margin-bottom: 5px;">
                <span>${getCircledNumber(ann.number)}</span>
                <span style="color: black; font-size: 14px;">"${ann.text}"</span>
                <button onclick="deleteAnnotationFromArea('${noteId}', '${ann.id}')" style="float: right; padding: 0px 8px; border: 2px solid black; background: white; cursor: pointer; font-size: 12px;">删除</button>
            </div>
            <textarea id="annotation-note-${ann.id}" style="width: 100%; min-height: 60px; padding: 5px; border: 2px solid black; font-size: 13px;" placeholder="在此输入注解内容...">${ann.note}</textarea>
        </div>
    `).join('');

    // 绑定textarea的change事件
    annotations.forEach(ann => {
        const textarea = document.getElementById(`annotation-note-${ann.id}`);
        if (textarea) {
            textarea.addEventListener('input', function() {
                const annotation = noteAnnotations[noteId].find(a => a.id === ann.id);
                if (annotation) {
                    annotation.note = this.value;
                }
            });
        }
    });
}


        
   
// 保存编辑的笔记
// 保存编辑的笔记
window.saveEditNote = async function (noteId) {
    const contentElement = document.getElementById(`edit-content-${noteId}`);
    const pageStartElement = document.getElementById(`edit-pageStart-${noteId}`);
    const pageEndElement = document.getElementById(`edit-pageEnd-${noteId}`);

    // 获取包含HTML的内容
    let htmlContent = contentElement.innerHTML;
    
    // 移除旧的带圈数字标记（来自之前的状态）
    htmlContent = htmlContent.replace(/<span[^>]*>[①-⑳⓪]<\/span>/g, '');
    htmlContent = htmlContent.replace(/[①-⑳⓪]/g, '');
    
    // 转换为纯文本，保留换行和段落
    let content = htmlContent
        .replace(/<div>/g, '\n')
        .replace(/<\/div>/g, '')
        .replace(/<br>/g, '\n')
        .replace(/&nbsp;/g, ' ')
        .replace(/<[^>]+>/g, '') // 移除剩余HTML标签
        .trim();
    
    // 首先进行分段处理，每段前面加两个全角空格
    content = content.split('\n').map(para => {
        const trimmed = para.trim();
        if (trimmed === '') {
            return ''; // 保持空行
        }
        
        let cleanPara = trimmed.replace(/^　+/g, '');
        return '　　' + cleanPara;
    }).join('\n');
    
    // 获取当前的注解数组
    const annotations = noteAnnotations[noteId] || [];
    
    // 如果有注解，在内容中插入新的带圈数字标记
    if (annotations.length > 0) {
        // 按number排序
        const sortedAnnotations = [...annotations].sort((a, b) => a.number - b.number);
        
        // 为每个注解查找文本并插入标记
        sortedAnnotations.forEach(ann => {
            if (ann.text && content.includes(ann.text)) {
                const circledNum = getCircledNumber(ann.number);
                // 只替换第一个匹配项
                const regex = new RegExp(ann.text.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g');
                let count = 0;
                content = content.replace(regex, (match) => {
                    count++;
                    return count === 1 ? match + circledNum : match;
                });
            }
        });
    }
    
    const pageStart = pageStartElement.value;
    const pageEnd = pageEndElement.value;

    // 重置边框颜色
    pageStartElement.style.borderColor = 'black';
    pageEndElement.style.borderColor = 'black';

    if (!content || content.trim() === '') {
        alert('请输入笔记内容');
        return;
    }

    // 验证页码：必须至少填写起始页
    if (!pageStart) {
        alert('请填写页码');
        return;
    }

    // 如果填写了结束页，验证结束页不能小于起始页
    if (pageEnd && parseInt(pageEnd) < parseInt(pageStart)) {
        alert('结束页不能小于起始页');
        return;
    }

    try {
        // 先更新笔记内容（包含重新编号后的标记）
        const { error: noteError } = await supabase
            .from('book_notes')
            .update({
                content: content, // 保存重新编号后的内容
                page_start: parseInt(pageStart),
                page_end: pageEnd ? parseInt(pageEnd) : null,
                updated_at: new Date().toISOString()
            })
            .eq('id', noteId);

        if (noteError) throw noteError;
        
        // 保存注解到数据库（使用重新编号后的序号）
        if (annotations.length > 0) {
            // 删除旧的注解
            const { error: deleteError } = await supabase
                .from('note_annotations')
                .delete()
                .eq('note_id', noteId);
            
            if (deleteError) throw deleteError;
            
            // 插入新的注解（按重新编号后的顺序）
            const annotationsToInsert = annotations.map((ann) => ({
                note_id: noteId,
                original_text: ann.text,
                annotation_text: ann.note || '',
                display_order: ann.number, // 使用重新编号后的序号
                created_at: new Date().toISOString()
            }));
            
            const { error: insertError } = await supabase
                .from('note_annotations')
                .insert(annotationsToInsert);
                
            if (insertError) throw insertError;
        } else {
            // 如果没有注解，删除所有相关注解
            await supabase
                .from('note_annotations')
                .delete()
                .eq('note_id', noteId);
        }
        
        // 清除缓存
        if (bookNotesCache[currentBookId]) {
            delete bookNotesCache[currentBookId];
        }
        
        // 清除当前笔记的注解缓存
        if (noteAnnotations[noteId]) {
            delete noteAnnotations[noteId];
        }

        // 重新加载笔记列表
        await loadUserNotes(currentBookId);
        await updateBookCounts();

        // 如果笔记区域是展开的，刷新它
        const notesArea = document.getElementById(`notes-area-${currentBookId}`);
        if (notesArea && notesArea.classList.contains('show')) {
            // 重新加载所有笔记
            await loadAllNotes(currentBookId);
            
            // 找到当前笔记的新索引
            const notes = bookNotesCache[currentBookId] || [];
            const currentIndex = notes.findIndex(note => note.id === noteId);
            if (currentIndex !== -1) {
                currentNoteIndex[currentBookId] = currentIndex;
            }
            
            // 重新显示当前笔记
            await displayCurrentNote(currentBookId);
        }

        // 显示成功消息
        alert('保存成功！');

    } catch (error) {
        console.error('更新笔记失败:', error);
        alert('更新失败，请重试');
    }
}


            window.deleteNote = async function (noteId) {
                if (!confirm('确定要删除这条笔记吗？')) {
                    return;
                }

                try {
                    const { error } = await supabase
                        .from('book_notes')
                        .delete()
                        .eq('id', noteId);

                    if (error) throw error;

                    await loadUserNotes(currentBookId);
                    await updateBookCounts();

                    // 如果笔记区域是展开的，刷新它
                    const notesArea = document.getElementById(`notes-area-${currentBookId}`);
                    if (notesArea && notesArea.classList.contains('show')) {
                        await loadAllNotes(currentBookId);
                        // 如果当前索引超出范围，调整到最后一条
                        const notes = bookNotesCache[currentBookId] || [];
                        if (currentNoteIndex[currentBookId] >= notes.length) {
                            currentNoteIndex[currentBookId] = Math.max(0, notes.length - 1);
                        }
                        displayCurrentNote(currentBookId);
                    }

                } catch (error) {
                    console.error('删除笔记失败:', error);
                    alert('删除失败，请重试');
                }
            }



         // 打印笔记功能
window.printNote = function(bookId, noteIndex) {
    const notes = bookNotesCache[bookId] || [];
    if (notes.length === 0 || noteIndex >= notes.length) {
        alert('没有可打印的笔记');
        return;
    }

    const note = notes[noteIndex];
    const bookData = window.BOOKS_DATA[bookId];
    const bookTitle = bookData ? bookData.title : '未知书籍';
    const bookImgSrc = bookData ? bookData.imgSrc : '';
    
    // 获取注解
    getNoteAnnotations(note.id).then(annotations => {
        // 创建打印窗口
        const printWindow = window.open('', '_blank');
        
        let pageInfo = '';
        if (note.page_start && note.page_end) {
            pageInfo = `P${note.page_start}-${note.page_end}`;
        } else if (note.page_start) {
            pageInfo = `P${note.page_start}`;
        }

        const annotationsHtml = renderAnnotationsForPrint(annotations);

        const printContent = `
            <!DOCTYPE html>
            <html>
            <head>
                <meta charset="UTF-8">
                <title>打印笔记 - ${bookTitle}</title>
                <style>
                    body {
                        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
                        padding: 40px;
                        max-width: 800px;
                        margin: 0 auto;
                    }
                    .book-meta {
                        font-size: 16px;
                        margin-bottom: 15px;
                        line-height: 1.6;
                        text-align: center;
                    }
                    .book-title {
                        font-size: 24px;
                        font-weight: bold;
                        margin-bottom: 10px;
                        text-align: center;
                    }
                    .page-info {
                        margin-top: -5px;
                        font-size: 16px;
                        text-align: center;
                    }
                    .header {
                        display: flex;
                        flex-direction: column;
                        align-items: center;
                        justify-content: center;
                        margin-bottom: 20px;
                        width: 100%;
                    }
                    .book-cover {
                        width: 250px;          
                        object-fit: cover;
                        margin-bottom: 20px;
                    }
                    .book-info {
                        text-align: center;
                        width: 100%;
                    }
                    .book-title {
                        font-size: 28px;
                        font-weight: bold;
                        margin-bottom: 15px;
                        text-align: center;
                    }
                    .note-content {
                        font-size: 16px;
                        line-height: 1.6;
                        white-space: pre-wrap;
                        margin-bottom: 20px;
                    }
                    .annotations-section {
                        margin-top: 30px;
                        padding-top: 20px;
                        border-top: 1px solid #ddd;
                    }
                    .annotations-title {
                        font-weight: bold;
                        margin-bottom: 10px;
                        font-size: 16px;
                    }
                    .annotation-item {
                        margin-bottom: 10px;
                        line-height: 1.5;
                    }
                    .annotation-marker {
                        color: #0066cc;
                        font-weight: bold;
                        margin-right: 8px;
                    }
                    .print-date {
                        margin-top: 30px;
                        font-size: 14px;
                        text-align: center;
                        line-height: 1.6;
                    }
                    @media print {
                        body {
                            align-items: center;
                        }
                    }
                </style>
            </head>
            <body>
                <div class="header">
                    ${bookImgSrc ? `
                        <img class="book-cover" src="${bookImgSrc}" alt="${bookTitle}" onerror="this.style.display='none'">
                    ` : ''}
                    <div class="book-info">
                        <div class="book-title">${bookTitle}</div>
                        <div class="book-meta">
                            ${bookData ? `
                                ${bookData.author || ''}
                                ${bookData.translator ? ' / ' + bookData.translator : ''}
                                ${bookData.publisher ? ' / ' + bookData.publisher : ''}
                                ${bookData.publishDate ? ' / ' + bookData.publishDate : ''}
                            ` : ''}
                        </div>
                        ${pageInfo ? `<div class="page-info">${pageInfo}</div>` : ''}
                    </div>
                </div>
                
                <div class="note-content">${note.content}</div>
                
                ${annotationsHtml}
                
                <div class="print-date">
                    CREATED AT: ${new Date(note.created_at).toLocaleString('zh-CN')}<br>
                    PRINTED AT: ${new Date().toLocaleString('zh-CN')}
                </div>
                <script>
                    window.onload = function() {
                        setTimeout(function() {
                            window.print();
                            setTimeout(function() {
                                window.close();
                            }, 5000);
                        }, 500);
                    }
                <\\/script>
            <\\/body>
            <\\/html>
        `;

        printWindow.document.write(printContent);
        printWindow.document.close();
    });
};

// 渲染打印用的注解
function renderAnnotationsForPrint(annotations) {
    if (!annotations || annotations.length === 0) {
        return '';
    }

    // 按显示顺序排序
    const sortedAnnotations = [...annotations].sort((a, b) => a.display_order - b.display_order);
    
    return `
        <div class="annotations-section">
            <div class="annotations-title">注解:</div>
            ${sortedAnnotations.map(ann => `
                <div class="annotation-item">
                    <span class="annotation-marker">${getCircledNumber(ann.display_order)}</span>
                    <span class="annotation-text">${ann.annotation_text}</span>
                </div>
            `).join('')}
        </div>
    `;
}

            // 点击Modal外部关闭
            document.getElementById('noteModal').addEventListener('click', function (e) {
                if (e.target === this) {
                    closeNoteModal();
                }
            });

        })();</script><script defer="defer" src="/js/vendors.1e26f8ac0292fd96d6e1.js"></script><script defer="defer" src="/js/styles.7aae21adbc8ce89b8327.js"></script><script defer="defer" src="/js/global.d5c953b80d30441fbf4f.js"></script></body>